# llms.txt — Agent Guide for `node-env-resolver`

**Purpose:** Teach coding agents how to resolve environment variables with types, validation, and multiple sources (resolvers) using `node-env-resolver`.

## TL;DR

* Use `resolve({...})` for the simple case (reads **process.env** only).
* Use `resolve.with([provider, schema], … [, options])` when you need **multiple resolvers** (e.g. dotenv + AWS Secrets).
* Merge rule is **left → right**, **last tuple wins** on key conflicts.
* In production, `.env` files are **not** read unless you explicitly include `dotenv()`.

---

## Primary APIs

### 1) Single-provider (default: process.env)

**Throws on error (like Zod's `parse()`):**
```ts
import { resolve } from 'node-env-resolver';

const config = await resolve({
  PORT: 3000,
  DATABASE_URL: 'url',
  DEBUG: false,
  API_KEY: 'string?'
});

// Types:
// PORT: number
// DATABASE_URL: string (validated URL string)
// DEBUG: boolean
// API_KEY: string | undefined
```

**Safe version - returns result object (like Zod's `safeParse()`):**
```ts
import { safeResolve } from 'node-env-resolver';

const result = await safeResolve({
  PORT: 'number',
  DATABASE_URL: 'url',
  API_KEY: 'string',
});

if (result.success) {
  console.log(result.data.PORT);  // Fully typed
} else {
  console.error(result.error);    // Error message
}
```

### 1b) Sync versions

For synchronous config loading (e.g., Next.js config files):

```ts
import { resolveSync, safeResolveSync } from 'node-env-resolver';

// Throws on error
const config = resolveSync({
  PORT: 3000,
  NODE_ENV: ['development', 'production'] as const
});

// Returns result object
const result = safeResolveSync({
  PORT: 3000,
  DEBUG: false
});

if (result.success) {
  console.log(result.data.PORT);
}
```

**Note:** Sync versions cannot use async validators (Zod, Valibot). Use shorthand syntax only.


### 2) Multi-provider (tuple syntax)

**Throws on error:**
```ts
import { resolve, processEnv, dotenv } from 'node-env-resolver';

const config = await resolve.with(
  [dotenv({ path: '.env', expand: true }), {
    DATABASE_URL: 'url',
    DEBUG: false
  }],
  [processEnv(), {
    PORT: 3000,
    NODE_ENV: ['development', 'production'] as const
  }]
);
```

**Safe version - returns result object:**
```ts
import { safeResolve, processEnv } from 'node-env-resolver';
import { awsSecrets } from 'node-env-resolver-aws';

const result = await safeResolve.with(
  [processEnv(), { PORT: 3000 }],
  [awsSecrets({ secretId: 'prod/secrets' }), { DATABASE_URL: 'postgres' }]
);

if (!result.success) {
  console.error('Config failed:', result.error);
  process.exit(1);
}

const config = result.data;
```

**Order rule:** Later tuples override earlier ones for overlapping keys.

### 3) Correct syntax for `.with()` (IMPORTANT!)

**✅ CORRECT** - Spread arguments directly, no wrapper array:
```ts
await resolve.with(
  [processEnv(), { PORT: 3000 }],
  [dotenv(), { DATABASE_URL: 'url' }]
);
```

**❌ WRONG** - Don't wrap in extra array:
```ts
// This will fail with "Invalid environment variable name: 0, 1"
await resolve.with([
  [processEnv(), { PORT: 3000 }],
  [dotenv(), { DATABASE_URL: 'url' }]
]);
```

**Why?** The function signature is variadic `...tuples`, not `tuples[]`.

### 4) Options (optional last argument to `.with`)

```ts
await resolve.with(
  [processEnv(), { PORT: 3000 }],
  [dotenv(),     { DATABASE_URL: 'url' }],
  {
    strict: true,
    interpolate: false,
    policies: {
      enforceAllowedSources: {
        DATABASE_URL: ['aws-secrets']
      }
    },
    // extend/resolvers: low-level hooks; prefer tuples for clarity
  }
);
```

---

## Resolver Model

A **resolver** (provider) returns a map of string values.

```ts
export interface Resolver {
  name: string;                              // Unique name for logging
  load(): Promise<Record<string, string>>;   // Async loader
  loadSync?(): Record<string, string>;       // Optional sync loader
  metadata?: Record<string, unknown>;        // Optional (e.g., { cached: true })
}
```

### Built-in resolvers

```ts
import { processEnv, dotenv } from 'node-env-resolver';

// Load from process.env
processEnv()

// Load from .env file
dotenv('.env')
dotenv({ path: '.env.production' })

// Load with expand mode (multiple .env files)
dotenv({ path: '.env', expand: true })
// Loads: .env.defaults, .env, .env.local, .env.${NODE_ENV}, .env.${NODE_ENV}.local
```

### Custom resolvers

**Simple object resolver:**
```ts
const databaseResolver: Resolver = {
  name: 'database',
  async load() {
    const rows = await db.query('SELECT key, value FROM config');
    return Object.fromEntries(rows.map(r => [r.key, r.value]));
  }
};

// Use it
await resolve.with(
  [processEnv(), { PORT: 3000 }],
  [databaseResolver, { FEATURE_FLAGS: 'json' }]
);
```

**Factory resolver (with options):**
```ts
function apiResolver(url: string): Resolver {
  return {
    name: `api(${url})`,
    async load() {
      const response = await fetch(url);
      return response.json();
    }
  };
}

await resolve.with(
  [processEnv(), { PORT: 3000 }],
  [apiResolver('https://config.example.com/api'), { RATE_LIMIT: 'number' }]
);
```

**AWS Secrets Manager:**
```ts
import { awsSecrets, awsSsm } from 'node-env-resolver-aws';

await resolve.with(
  [processEnv(), { PORT: 3000 }],
  [awsSecrets({ secretId: 'prod/db' }), { DATABASE_URL: 'postgres' }],
  [awsSsm({ path: '/myapp/config', recursive: true }), { API_KEY: 'string' }]
);
```

**Wrappers** (decorators) return new resolvers:

```ts
import { cached, retry, TTL } from 'node-env-resolver';

const stableAws = cached(
  retry(awsSecretsProvider({ region: 'us-east-1' }), { attempts: 3 }),
  { ttl: TTL.minutes5, staleWhileRevalidate: true }
);
```

---

## Schema DSL (Standard Schema–style)

### Shorthand types

* `'string'` - Required string
* `'string?'` - Optional string
* `'number'` - Required number
* `'boolean'` - Required boolean
* `'url'` - Validated URL string
* `'email'` - Validated email
* `'port'` - Port number (1-65535)
* `'json'` - Parsed JSON (typed as `unknown`, narrow manually)
* `'postgres'`, `'mysql'`, `'mongodb'`, `'redis'` - Database connection strings

### Pattern matching

```ts
API_KEY: 'string:/^sk_[a-zA-Z0-9]+$/'  // Regex pattern
```

### Literals & defaults

```ts
PORT: 3000,                                        // number with default 3000
DEBUG: false,                                      // boolean with default false
NODE_ENV: ['development','production'] as const    // enum union
```

**IMPORTANT difference:**
- `PORT: 3000` - Uses default if missing (no error)
- `PORT: 'number'` - Required, throws if missing
- `PORT: 'number?'` - Optional, returns `undefined` if missing

### Advanced object form

```ts
API_KEY: {
  type: 'string',
  optional: true,
  pattern: '^sk_[a-zA-Z0-9]+$',
  description: 'Secret key'
}
```

### Custom validators

```ts
const portValidator = (value: string): number => {
  const port = parseInt(value, 10);
  if (isNaN(port) || port < 1 || port > 65535) {
    throw new Error('Invalid port');
  }
  return port;
};

const config = await resolve({
  CUSTOM_PORT: portValidator,
  DATABASE_URL: 'postgres'
});
```

---

## Behavior & Policies

* **Default source**: `resolve({...})` reads **process.env only** (consistent across dev/staging/prod).
* **Dotenv**: Add `dotenv()` explicitly when you want `.env` files (usually development).
* **Merging**: Tuples merge **left → right**; later resolvers overwrite earlier ones on the same key.
* **Security defaults**:

  * Production-safe by default (dotenv not used unless included).
  * Optional audit logging (`getAuditLog()`).
  * Optional **source enforcement** via `policies.enforceAllowedSources`.

---

## Error Handling

Typical failures:

* Missing required variable
* Invalid type/format (url/email/number/port)
* Enum mismatch
* Regex/pattern mismatch

Example:

```
❌ Environment validation failed:
  - Missing required environment variable: DATABASE_URL
  - PORT: Invalid port number (1-65535)
  - NODE_ENV: must be one of: development, production
  - API_KEY: does not match pattern: ^sk_[a-zA-Z0-9]+$
```

**Recommendation for agents:** When validation fails, propose the minimal fix:

* Add missing variable(s) to the correct source.
* Adjust schema (e.g., make optional) only if the product spec allows it.

---

## Do / Don’t (for Agents)

**Do**

* Prefer `resolve({...})` if only `process.env` is needed.
* Use `resolve.with([provider, schema], …)` for multiple sources; keep **one source per key** if possible.
* Preserve tuple literal types with `as const` when storing tuples.
* Document provider **order** explicitly in code reviews and PRs.

**Don’t**

* Don’t use object mapping like `{ provider: { …schema } }` — use tuples.
* Don’t silently add dotenv in production.
* Don’t mix overlapping keys across resolvers unless there’s an explicit override reason.

---

## Common Recipes

### 1) Safe resolve with error handling

```ts
import { safeResolve } from 'node-env-resolver';

const result = await safeResolve({
  PORT: 'number',
  DATABASE_URL: 'postgres',
  API_KEY: 'string'
});

if (!result.success) {
  console.error('❌ Config validation failed:');
  console.error(result.error);
  process.exit(1);
}

// Now use result.data safely
const app = createApp(result.data);
```

### 2) Strict prod, dotenv in dev

```ts
import { resolve, processEnv, dotenv } from 'node-env-resolver';

const config = await resolve.with(
  [dotenv(), { DATABASE_URL: 'url', DEBUG: false }],
  [processEnv(), { PORT: 3000, NODE_ENV: ['development','production'] as const }],
  {
    strict: true,
    policies: {
      enforceAllowedSources: {
        DATABASE_URL: ['aws-secrets'], // require secret to come from aws
      },
    },
  }
);
```

### 3) AWS Secrets + cache + retry

```ts
import { resolve, processEnv, cached, retry, TTL } from 'node-env-resolver';
import { awsSecrets } from 'node-env-resolver-aws';

const config = await resolve.with(
  [processEnv(), { PORT: 3000 }],
  [
    cached(
      retry(awsSecrets({ secretId: 'prod/secrets' }), { attempts: 3 }),
      { ttl: TTL.minutes15 }
    ),
    { DATABASE_URL: 'url', API_KEY: 'string' }
  ]
);
```

### 4) Custom database resolver

```ts
import { safeResolve, processEnv, type Resolver } from 'node-env-resolver';

const dbResolver: Resolver = {
  name: 'postgres-config',
  async load() {
    const client = await db.connect();
    const result = await client.query('SELECT key, value FROM app_config');
    return Object.fromEntries(result.rows.map(r => [r.key, r.value]));
  }
};

const result = await safeResolve.with(
  [processEnv(), { PORT: 3000, NODE_ENV: ['dev', 'prod'] as const }],
  [dbResolver, { FEATURE_FLAGS: 'json', RATE_LIMIT: 'number' }]
);

if (!result.success) {
  console.error('Config failed:', result.error);
  process.exit(1);
}
```

### 5) JSON flags (narrow after parse)

```ts
const { FEATURE_FLAGS } = await resolve({
  FEATURE_FLAGS: 'json'
});
const flags = FEATURE_FLAGS as { newUI?: boolean };
```

---

## Minimal Signature Cheatsheet

```ts
// Primary - throws on error
resolve(schema: Schema): Promise<TypedConfig>
resolve.with(...tuples: [Resolver, Schema][], options?: ResolveOptions): Promise<MergedConfig>

// Safe - returns result object
safeResolve(schema: Schema): Promise<{ success: true, data: TypedConfig } | { success: false, error: string }>
safeResolve.with(...tuples): Promise<{ success: true, data: MergedConfig } | { success: false, error: string }>

// Sync versions
resolveSync(schema: Schema): TypedConfig                    // Throws
safeResolveSync(schema: Schema): { success, data?, error? } // Returns result
resolveSync.with(...tuples): MergedConfig                   // Throws
safeResolveSync.with(...tuples): { success, data?, error? } // Returns result

// Resolvers
interface Resolver {
  name: string;
  load(): Promise<Record<string,string>>;
  loadSync?(): Record<string,string>;
  metadata?: Record<string, unknown>;
}

// Built-in resolvers
processEnv(): Resolver
dotenv(path?: string | { path?: string, expand?: boolean }): Resolver

// Utilities
cached(resolver: Resolver, opts: { ttl: number }): Resolver
retry(resolver: Resolver, opts: { attempts: number }): Resolver
TTL.minute, TTL.minutes5, TTL.hour, TTL.day  // Constants

// Options (subset)
interface ResolveOptions {
  interpolate?: boolean;  // ${VAR} expansion (default: true)
  strict?: boolean;       // Fail on resolver errors (default: true)
  policies?: {
    enforceAllowedSources?: Record<string, string[]>; // key → allowed provider names
  };
}
```

---

## Test Hints (for Agents)

* Unit tests: verify types with `// @ts-expect-error` for invalid shapes.
* Integration: simulate provider order & conflicts; assert **last-wins**.
* Security: ensure `.env` is ignored unless `dotenv()` present; assert source enforcement errors.
* JSON schema: ensure `'json'` parses and is typed `unknown`.

---

## Zod Integration

Use Zod schemas directly for validation:

```ts
import { resolveZod, safeResolveZod, resolveSyncZod, safeResolveSyncZod } from 'node-env-resolver/zod';
import { z } from 'zod';

const schema = z.object({
  PORT: z.coerce.number().default(3000),
  DATABASE_URL: z.string().url(),
  NODE_ENV: z.enum(['development', 'production', 'test']),
  DEBUG: z.coerce.boolean().optional(),
});

// Throws on validation error
const env = await resolveZod(schema);

// Returns result object (safe version)
const result = await safeResolveZod(schema);
if (result.success) {
  console.log(result.data.PORT);
} else {
  console.error(result.error);
}

// Sync versions
const envSync = resolveSyncZod(schema);
const resultSync = safeResolveSyncZod(schema);
```

**With multiple resolvers:**
```ts
import { resolveZod, processEnv, dotenv } from 'node-env-resolver/zod';
import { awsSecrets } from 'node-env-resolver-aws';

const env = await resolveZod(schema, {
  resolvers: [
    dotenv(),
    processEnv(),
    awsSecrets({ secretId: 'prod/secrets' })
  ],
  interpolate: true,
  strict: true
});
```

**API:**
- `resolveZod()` - Throws on error
- `safeResolveZod()` - Returns `{ success, data?, error? }`
- `resolveSyncZod()` - Sync, throws on error
- `safeResolveSyncZod()` - Sync, returns result object

---

## Migration Tips (from t3-env or Zod)

* Replace `z.enum([...])` with `['a','b'] as const`.
* Replace `.default(3000)` with literal `3000`.
* Replace `runtimeEnv: process.env` with `resolve({...})`.
* For multi-source needs, move to `resolve.with([provider, schema], …)`.
* If you prefer Zod schemas, use `resolveZod()` from `node-env-resolver/zod`.

---

**Contact:** If you’re an agent proposing changes, prefer PRs that:

* Keep one source per key where possible.
* Include error messages that mention **which provider** a value came from.
* Preserve tuple order and `as const` annotations.