# llms.txt — Agent Guide for `node-env-resolver`

**Purpose:** Teach coding agents how to resolve environment variables with types, validation, and multiple sources (resolvers) using `node-env-resolver`.

## TL;DR

* Use `resolve({...})` for the simple case (reads **process.env** only, synchronous).
* Use `resolveAsync([provider, schema], … [, options])` when you need **multiple async resolvers** (e.g. dotenv + AWS Secrets).
* **NEW:** `resolve()` now supports **multiple sync resolvers** using the same tuple syntax.
* Merge rule is **left → right**, **last tuple wins** on key conflicts (default).
* Use `priority: 'first'` option to reverse precedence (first tuple wins).
* **NEW:** Use `getAuditLog(config)` to get audit events for a specific config object.
* In production, `.env` files are **not** read unless you explicitly include `dotenv()`.

---

## Primary APIs

### 1) Single-provider (default: process.env)

**Throws on error (like Zod's `parse()`):**
```ts
import { resolve } from 'node-env-resolver';

const config = resolve({
  PORT: 3000,
  DATABASE_URL: url(),
  DEBUG: false,
  API_KEY: string({optional:true})
});

// Types:
// PORT: number
// DATABASE_URL: string (validated URL string)
// DEBUG: boolean
// API_KEY: string | undefined
```

**Safe version - returns result object (like Zod's `safeParse()`):**
```ts
import { safeResolve } from 'node-env-resolver';

const result = safeResolve({
  PORT: 'number',
  DATABASE_URL: url(),
  API_KEY: string(),
});

if (result.success) {
  console.log(result.data.PORT);  // Fully typed
} else {
  console.error(result.error);    // Error message
}
```


### 2) Multi-provider (tuple syntax)

**Async - supports both sync and async resolvers:**
```ts
import { resolve, processEnv } from 'node-env-resolver';
import { dotenv } from 'node-env-resolver/resolvers';

const config = await resolveAsync(
  [dotenv({ path: '.env', expand: true }), {
    DATABASE_URL: url(),
    DEBUG: false
  }],
  [processEnv(), {
    PORT: 3000,
    NODE_ENV: ['development', 'production'] as const
  }]
);
```

**Sync - supports multiple SYNC resolvers (NEW!):**
```ts
import { resolve } from 'node-env-resolver';
import { dotenv, json } from 'node-env-resolver/resolvers';

// Both dotenv() and json() have loadSync() - works synchronously!
const config = resolve(
  [dotenv(), { PORT: 3000 }],
  [json('config.json'), { DATABASE_URL: postgres() }],
  { priority: 'last' }  // Priority works in sync mode too
);
```

**Safe version - returns result object:**
```ts
import { safeResolve, processEnv } from 'node-env-resolver';
import { awsSecrets } from 'node-env-resolver-aws';

const result = await saferesolveAsync(
  [processEnv(), { PORT: 3000 }],
  [awsSecrets({ secretId: 'prod/secrets' }), { DATABASE_URL: postgres() }]
);

if (!result.success) {
  console.error('Config failed:', result.error);
  process.exit(1);
}

const config = result.data;
```

**Order rule:** Later tuples override earlier ones for overlapping keys (default `priority: 'last'`).

### 2b) Priority control

Control merge behaviour when multiple resolvers provide the same variable:

```ts
// priority: 'last' (default) - later resolvers override earlier ones
const config = await resolveAsync(
  [processEnv(), { DATABASE_URL: url() }],
  [awsSecrets({ secretId: 'prod/secrets' }), { DATABASE_URL: url() }]
  // AWS wins (last resolver)
);

// priority: 'first' - earlier resolvers take precedence
const config = await resolveAsync(
  [dotenv(), { DATABASE_URL: url() }],
  [awsSecrets({ secretId: 'prod/secrets' }), { DATABASE_URL: url() }],
  { priority: 'first' }
  // dotenv wins (first resolver)
);
```

**Use cases:**
- `priority: 'last'` (default): Production secrets override local env
- `priority: 'first'`: Local .env overrides cloud secrets (development workflow)

**Semantics:**
- Only `undefined` means "not set"
- Empty strings, `null`, and other values are considered "set"
- With `priority: 'first'`, later resolvers only set values that are `undefined`

### 3) Correct syntax for `.async()` (IMPORTANT!)

**✅ CORRECT** - Spread arguments directly, no wrapper array:
```ts
await resolveAsync(
  [processEnv(), { PORT: 3000 }],
  [dotenv(), { DATABASE_URL: url() }]
);
```

**❌ WRONG** - Don't wrap in extra array:
```ts
// This will fail with "Invalid environment variable name: 0, 1"
await resolveAsync([
  [processEnv(), { PORT: 3000 }],
  [dotenv(), { DATABASE_URL: url() }]
]);
```

**Why?** The function signature is variadic `...tuples`, not `tuples[]`.

### 4) Options (optional last argument)

**For single source:**
```ts
resolve(
  { PORT: 3000, DATABASE_URL: url() },
  {
    strict: true,        // Fail on validation errors (default: true)
    interpolate: false,  // ${VAR} expansion (default: true)
    enableAudit: true    // Enable audit logging
  }
);
```

**For multiple sources (`.async`):**
```ts
await resolveAsync(
  [processEnv(), { PORT: 3000 }],
  [dotenv(),     { DATABASE_URL: url() }],
  {
    priority: 'first' | 'last',  // Merge strategy (default: 'last')
    strict: true,                 // Fail on resolver errors (default: true)
    interpolate: false,           // ${VAR} expansion (default: true)
    policies: {
      enforceAllowedSources: {
        DATABASE_URL: ['aws-secrets']
      }
    },
    enableAudit: true             // Enable audit logging
  }
);
```

---

## Resolver Model

A **resolver** (provider) returns a map of string values.

```ts
export interface Resolver {
  name: string;                              // Unique name for logging
  load(): Promise<Record<string, string>>;   // Async loader
  loadSync?(): Record<string, string>;       // Optional sync loader
  metadata?: Record<string, unknown>;        // Optional (e.g., { cached: true })
}
```

### Built-in resolvers

```ts
import { processEnv } from 'node-env-resolver';
import { dotenv, secrets } from 'node-env-resolver/resolvers';
import { cliArgs } from 'node-env-resolver/cli';

// Load from process.env
processEnv()

// Load from .env file
dotenv('.env')
dotenv({ path: '.env.production' })

// Load with expand mode (multiple .env files)
dotenv({ path: '.env', expand: true })
// Loads: .env.defaults, .env, .env.local, .env.${NODE_ENV}, .env.${NODE_ENV}.local

// Load from CLI arguments
cliArgs()  // Parses process.argv (--port 8080 → PORT=8080)
cliArgs({ argv: ['--port', '8080', '--verbose'] })

// Load from Docker/K8s secrets directory
secrets('/run/secrets')  // Reads all files in directory
```

### AWS resolvers

**Option 1: One-line convenience functions (recommended for single source)**

```ts
import { resolveSsm, resolveSecrets, safeResolveSsm, safeResolveSecrets } from 'node-env-resolver-aws';

// SSM Parameter Store
const config = await resolveSsm({
  path: '/myapp/config',
  region: 'us-east-1',
  recursive: true
}, {
  API_ENDPOINT: url(),
  TIMEOUT: 30
});

// Secrets Manager
const secrets = await resolveSecrets({
  secretId: 'myapp/production/secrets',
  region: 'us-east-1'
}, {
  DATABASE_URL: url(),
  API_KEY: string()
});

// Safe versions (return result object)
const result = await safeResolveSecrets({
  secretId: 'myapp/secrets'
}, {
  DATABASE_URL: url()
});

if (result.success) {
  console.log(result.data.DATABASE_URL);
} else {
  console.error(result.error);
}
```

**Option 2: Using with multiple sources**

```ts
import { resolve } from 'node-env-resolver';
import { awsSecrets, awsSsm } from 'node-env-resolver-aws';

const config = await resolveAsync(
  [processEnv(), { PORT: 3000 }],
  [awsSecrets({ secretId: 'prod/db' }), { DATABASE_URL: postgres() }],
  [awsSsm({ path: '/myapp/config', recursive: true }), { API_KEY: string() }]
);
```

**AWS credentials:**
- Automatically uses AWS SDK credential provider chain
- Environment variables: `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_REGION`
- IAM roles (EC2, Lambda, ECS)
- AWS credentials file (`~/.aws/credentials`)
- No explicit configuration needed in most cases

### Custom resolvers

**Simple object resolver:**
```ts
const databaseResolver: Resolver = {
  name: 'database',
  async load() {
    const rows = await db.query('SELECT key, value FROM config');
    return Object.fromEntries(rows.map(r => [r.key, r.value]));
  }
};

// Use it
await resolveAsync(
  [processEnv(), { PORT: 3000 }],
  [databaseResolver, { FEATURE_FLAGS: 'json' }]
);
```

**Factory resolver (with options):**
```ts
function apiResolver(url: string): Resolver {
  return {
    name: `api(${url})`,
    async load() {
      const response = await fetch(url);
      return response.json();
    }
  };
}

await resolveAsync(
  [processEnv(), { PORT: 3000 }],
  [apiResolver('https://config.example.com/api'), { RATE_LIMIT: 'number' }]
);
```

### Resolver wrappers

**Wrappers** (decorators) return new resolvers:

```ts
import { cached, retry, TTL, awsCache } from 'node-env-resolver/utils';
import { awsSecrets } from 'node-env-resolver-aws';

// TTL caching (manual configuration)
cached(awsSecrets({ secretId: 'prod/secrets' }), {
  ttl: TTL.minutes5,
  maxAge: TTL.hour,
  staleWhileRevalidate: true  // Serve stale while refreshing in background
})

// TTL caching (AWS defaults helper - RECOMMENDED for AWS)
cached(awsSecrets({ secretId: 'prod/secrets' }), awsCache())
// awsCache() returns { ttl: 5min, maxAge: 1hr, staleWhileRevalidate: true }

// Retry on failure
retry(awsSecrets({ secretId: 'prod/secrets' }), 3, 1000)

// Combined
const stableAws = cached(
  retry(awsSecrets({ secretId: 'prod/secrets' }), 3),
  awsCache()  // Use AWS defaults
);

await resolveAsync(
  [processEnv(), { PORT: 3000 }],
  [stableAws, { DATABASE_URL: url(), API_KEY: string() }]
);
```

**Difference: `cached()` vs `awsCache()`**
- `cached(resolver, options)` - **Function** that wraps a resolver to add caching
- `awsCache(options?)` - **Helper** that returns AWS-optimized cache options

```ts
// These are equivalent:
cached(awsSecrets(...), { ttl: TTL.minutes5, maxAge: TTL.hour, staleWhileRevalidate: true })
cached(awsSecrets(...), awsCache())  // Cleaner!

// Custom AWS config:
cached(awsSecrets(...), awsCache({ ttl: TTL.minute, staleWhileRevalidate: false }))
```

**TTL constants:**
```ts
TTL.short      // 30 seconds
TTL.minute     // 60 seconds
TTL.minutes5   // 5 minutes
TTL.minutes15  // 15 minutes
TTL.hour       // 1 hour
TTL.hours6     // 6 hours
TTL.day        // 24 hours
```

**Cache options:**
```ts
interface CacheOptions {
  ttl?: number;                    // Cache duration in milliseconds (default: 5 minutes)
  maxAge?: number;                 // Maximum age before force refresh (default: 1 hour)
  staleWhileRevalidate?: boolean;  // Serve stale while refreshing (default: false)
  key?: string;                    // Custom cache key (optional)
}
```

**AWS cache defaults:**
```ts
awsCache()  // Returns:
// {
//   ttl: TTL.minutes5,          // 5 minutes
//   maxAge: TTL.hour,           // 1 hour
//   staleWhileRevalidate: true, // Enabled for AWS!
//   key: 'aws-secrets'
// }
```

**Important caching pattern for AWS:**
```ts
// ✅ CORRECT - Call resolve() every time, let cached() wrapper handle caching
export const getConfig = async () => {
  return await resolveAsync(
    [cached(
      awsSecrets({ secretId: 'app/secrets' }),
      { ttl: TTL.minutes5, staleWhileRevalidate: true }
    ), {
      DATABASE_URL: url(),
      API_KEY: string(),
    }]
  );
};

// In your handler
app.get('/api/data', async (req, res) => {
  const config = await getConfig(); // Fast after first call
  // Use config...
});

// ❌ WRONG - Don't cache the result
const config = resolve({...}); // Only called once
app.get('/api/data', (req, res) => {
  // Uses stale config forever
});
```

---

## Schema DSL (Standard Schema–style)

### Shorthand types

**Basic types:**
* `'string'` - Required string (empty strings rejected by default for security)
* `'string?'` - Optional string (empty → undefined)
* `'number'` - Required number (coerced from string)
* `'number?'` - Optional number
* `'boolean'` - Required boolean (coerced from 'true'/'false'/'1'/'0'/'yes'/'no')
* `'boolean?'` - Optional boolean

**Array types:**
* `'string[]'` - Array of strings (comma-separated: `'a,b,c'` → `['a','b','c']`)
* `'number[]'` - Array of numbers (comma-separated: `'1,2,3'` → `[1,2,3]`)
* `'url[]'` - Array of validated URLs (comma-separated, each validated)

**Network types:**
* `'url'` - Validated URL string
* `'http'` - HTTP URL
* `'https'` - HTTPS URL
* `'email'` - Validated email

**Database types:**
* `'postgres'` or `'postgresql'` - PostgreSQL connection string
* `'mysql'` - MySQL connection string
* `'mongodb'` - MongoDB connection string
* `'redis'` - Redis connection string

**Utility types:**
* `'port'` - Port number (1-65535)
* `'json'` - Parsed JSON (typed as `unknown`, narrow manually)
* `'duration'` - Time duration (`'5s'`, `'2m'`, `'1h'`, `'2h30m'` → milliseconds as number)
* `'file'` - Read content from file path (Docker/K8s secrets)

### Pattern matching

```ts
API_KEY: 'string:/^sk_[a-zA-Z0-9]+$/'  // Regex pattern
```

### Literals & defaults

```ts
PORT: 3000,                                        // number with default 3000
DEBUG: false,                                      // boolean with default false
LOG_LEVEL: 'info',                                 // string with default 'info'
NODE_ENV: ['development','production'] as const    // enum union
```

**IMPORTANT difference:**
- `PORT: 3000` - Uses default if missing (no error)
- `PORT: 'number'` - Required, throws if missing
- `PORT: 'number?'` - Optional, returns `undefined` if missing

### Advanced object form

```ts
API_KEY: {
  type: string(),
  optional: true,
  pattern: '^sk_[a-zA-Z0-9]+$',
  min: 32,
  max: 64,
  description: 'Secret key'
}
```

### Custom validators

```ts
const portValidator = (value: string): number => {
  const port = parseInt(value, 10);
  if (isNaN(port) || port < 1 || port > 65535) {
    throw new Error('Invalid port');
  }
  return port;
};

const isValidEmail = (value: string): string => {
  if (!value.includes('@')) {
    throw new Error('Invalid email address');
  }
  return value.toLowerCase();
};

const config = resolve({
  CUSTOM_PORT: portValidator,
  ADMIN_EMAIL: isValidEmail,
  DATABASE_URL: postgres()
});
```

---

## Behaviour & Policies

* **Default source**: `resolve({...})` reads **process.env only** (consistent across dev/staging/prod).
* **Dotenv**: Add `dotenv()` explicitly when you want `.env` files (usually development).
* **Merging**: Tuples merge **left → right**; later resolvers overwrite earlier ones on the same key (unless `priority: 'first'`).
* **Security defaults**:

  * Production-safe by default (dotenv not used unless included).
  * Optional audit logging (`getAuditLog()`).
  * Optional **source enforcement** via `policies.enforceAllowedSources`.

---

## Error Handling

Typical failures:

* Missing required variable
* Invalid type/format (url/email/number/port)
* Enum mismatch
* Regex/pattern mismatch

Example:

```
Environment validation failed:
  - Missing required environment variable: DATABASE_URL
  - PORT: Invalid port number (1-65535)
  - NODE_ENV: must be one of: development, production (got: "staging")
  - API_KEY: does not match pattern: ^sk_[a-zA-Z0-9]+$
```

**Recommendation for agents:** When validation fails, propose the minimal fix:

* Add missing variable(s) to the correct source.
* Adjust schema (e.g., make optional) only if the product spec allows it.

---

## Do / Don't (for Agents)

**Do**

* Prefer `resolve({...})` if only `process.env` is needed.
* Use `resolveAsync([provider, schema], …)` for multiple async resolvers.
* **NEW:** Use `resolve([resolver1, schema1], [resolver2, schema2], options)` for multiple **sync** resolvers.
* Use `priority: 'first'` for development workflows where local overrides should win.
* **NEW:** Use `getAuditLog(config)` to get audit events for a specific config object.
* Preserve tuple literal types with `as const` when storing tuples.
* Document provider **order** explicitly in code reviews and PRs.
* Use `cached()` wrapper for expensive operations (AWS API calls, database queries).
* Use `awsCache()` helper for AWS-optimized caching defaults (includes `staleWhileRevalidate: true`).
* Call `resolve()` every time in handlers - let `cached()` make it fast.
* Use `'string[]'` for comma-separated values (feature flags, origins, tags).
* Use `'duration'` for timeouts, TTLs, and time-based configs (Go-style: `'5s'`, `'2m'`).
* Use `secretsDir` option for Docker/K8s secrets (auto kebab-case conversion).
* Use `withComputed()` to derive URLs, connection strings, and feature flags from config.
* Use `cliArgs()` for CLI tools that need argument parsing.
* Empty strings are rejected by default - use `'string?'` for optional or defaults for fallback.

**Don't**

* Don't use object mapping like `{ provider: { …schema } }` — use tuples.
* Don't silently add dotenv in production.
* Don't mix overlapping keys across resolvers unless there's an explicit override reason.
* Don't cache the result of `resolve()` - cache the resolver instead.
* Don't forget `as const` for enum arrays.
* Don't use `{ type: string(), notEmpty: true }` - empty rejection is the default.
* Don't manually parse comma-separated values - use `'string[]'` or `'number[]'`.
* Don't manually parse durations - use `'duration'` type.
* Don't hardcode file paths when using Docker/K8s - use `secretsDir` option.

---

## Common Recipes

### 1) Safe resolve with error handling

```ts
import { safeResolve } from 'node-env-resolver';

const result = safeResolve({
  PORT: 'number',
  DATABASE_URL: postgres(),
  API_KEY: string()
});

if (!result.success) {
  console.error('Config validation failed:');
  console.error(result.error);
  process.exit(1);
}

// Now use result.data safely
const app = createApp(result.data);
```

### 2) Strict prod, dotenv in dev with priority control

```ts
import { resolve, processEnv, dotenv } from 'node-env-resolver';

// Development: local .env overrides everything
const config = await resolveAsync(
  [dotenv(), { DATABASE_URL: url(), DEBUG: false }],
  [processEnv(), { PORT: 3000, NODE_ENV: ['development','production'] as const }],
  { priority: 'first' }  // .env wins
);

// Production: cloud secrets override process.env
const config = await resolveAsync(
  [processEnv(), { PORT: 3000 }],
  [awsSecrets({ secretId: 'prod/secrets' }), { DATABASE_URL: url() }]
  // Default priority: 'last' - AWS wins
);
```

### 3) AWS Secrets + cache + retry

```ts
import { resolve, processEnv, cached, retry, TTL } from 'node-env-resolver';
import { awsSecrets } from 'node-env-resolver-aws';

const config = await resolveAsync(
  [processEnv(), { PORT: 3000 }],
  [
    cached(
      retry(awsSecrets({ secretId: 'prod/secrets' }), { attempts: 3 }),
      { ttl: TTL.minutes5, staleWhileRevalidate: true }
    ),
    { DATABASE_URL: url(), API_KEY: string() }
  ]
);
```

### 4) AWS one-liner with convenience functions

```ts
import { resolveSecrets, safeResolveSsm } from 'node-env-resolver-aws';

// Secrets Manager (throws on error)
const secrets = await resolveSecrets({
  secretId: 'myapp/production/secrets'
}, {
  DATABASE_URL: url(),
  API_KEY: string()
});

// SSM Parameter Store (safe version)
const result = await safeResolveSsm({
  path: '/myapp/config',
  recursive: true
}, {
  API_ENDPOINT: url()
});

if (!result.success) {
  console.error(result.error);
  process.exit(1);
}
```

### 5) Custom database resolver

```ts
import { safeResolve, processEnv, type Resolver } from 'node-env-resolver';

const dbResolver: Resolver = {
  name: 'postgres-config',
  async load() {
    const client = await db.connect();
    const result = await client.query('SELECT key, value FROM app_config');
    return Object.fromEntries(result.rows.map(r => [r.key, r.value]));
  }
};

const result = await saferesolveAsync(
  [processEnv(), { PORT: 3000, NODE_ENV: ['dev', 'prod'] as const }],
  [dbResolver, { FEATURE_FLAGS: 'json', RATE_LIMIT: 'number' }]
);

if (!result.success) {
  console.error('Config failed:', result.error);
  process.exit(1);
}
```

### 6) AWS Lambda with caching pattern

```ts
import { resolve, cached, TTL } from 'node-env-resolver';
import { awsSecrets } from 'node-env-resolver-aws';

// Define config loader (called every invocation)
export const getConfig = async () => {
  return await resolveAsync(
    [cached(
      awsSecrets({ secretId: 'lambda/config' }),
      { ttl: TTL.minutes5, staleWhileRevalidate: true }
    ), {
      DATABASE_URL: url(),
      API_KEY: string(),
    }]
  );
};

// Lambda handler
export const handler = async (event) => {
  const config = await getConfig(); // Fast after first call
  // Lambda container reuse = cache persists across invocations
  // Use config...
};
```

### 7) Express with cached AWS secrets

```ts
import express from 'express';
import { resolve, cached, TTL } from 'node-env-resolver';
import { awsSecrets } from 'node-env-resolver-aws';

const getConfig = async () => {
  return await resolveAsync(
    [cached(
      awsSecrets({ secretId: 'myapp/production' }),
      { ttl: TTL.minutes5, staleWhileRevalidate: true }
    ), {
      DATABASE_URL: url(),
      STRIPE_KEY: string(),
    }]
  );
};

const app = express();

app.get('/api/data', async (req, res) => {
  const config = await getConfig(); // Call every request - cached() makes it fast
  // Use config.DATABASE_URL, config.STRIPE_KEY
});

app.listen(3000);
```

### 8) Next.js App Router

```ts
import { resolve, cached, TTL } from 'node-env-resolver';
import { awsSecrets } from 'node-env-resolver-aws';

const getConfig = async () => {
  return await resolveAsync(
    [cached(
      awsSecrets({ secretId: 'myapp/nextjs' }),
      { ttl: TTL.minutes5, staleWhileRevalidate: true }
    ), {
      DATABASE_URL: url(),
    }]
  );
};

// API Route
export async function GET(request: Request) {
  const config = await getConfig(); // Call every request
  // Use config...
}

// Server Component
export default async function Page() {
  const config = await getConfig(); // Call for each render
  // Use config...
}
```

### 9) JSON flags (narrow after parse)

```ts
const { FEATURE_FLAGS } = resolve({
  FEATURE_FLAGS: 'json'
});

// Narrow the type manually
const flags = FEATURE_FLAGS as { newUI?: boolean; darkMode?: boolean };

if (flags.newUI) {
  // Use new UI
}
```

### 10) CLI arguments for build tools

```ts
import { resolve } from 'node-env-resolver';
import { cliArgs } from 'node-env-resolver/cli';

// $ node build.js --input ./src --output ./dist --minify --workers 4

const config = await resolveAsync(
  [processEnv(), { INPUT: string(), OUTPUT: string(), MINIFY: false, WORKERS: 'number' }],
  [cliArgs(), { INPUT: string(), OUTPUT: string(), MINIFY: false, WORKERS: 'number' }]
);

// config.INPUT === './src' (from CLI)
// config.OUTPUT === './dist' (from CLI)
// config.MINIFY === true (boolean flag)
// config.WORKERS === 4 (parsed as number)
```

**CLI arg formats:**
- `--port 8080` → `PORT='8080'`
- `--port=8080` → `PORT='8080'`
- `--verbose` → `VERBOSE='true'` (boolean flag)
- `--database-url postgres://...` → `DATABASE_URL='postgres://...'` (kebab→SNAKE)

### 11) Array types (feature flags, CORS origins, ports)

```ts
// Feature flags
process.env.FEATURES = 'analytics,caching,monitoring';

const config = resolve({
  FEATURES: 'string[]'  // ['analytics', 'caching', 'monitoring']
});

// CORS origins
process.env.ALLOWED_ORIGINS = 'https://app.com,https://api.com,http://localhost:3000';

const config = await resolveAsync([processEnv(), {
  ALLOWED_ORIGINS: 'url[]'  // Each URL is validated
}]);

// Multiple ports
process.env.PORTS = '3000,8080,9000';

const config = resolve({
  PORTS: 'number[]',  // [3000, 8080, 9000]
  TAGS: { type: 'string[]', separator: '|' }  // Custom separator
});
```

### 12) Duration parsing (Go-style)

```ts
process.env.TIMEOUT = '30s';
process.env.CACHE_TTL = '5m';
process.env.SESSION_DURATION = '2h30m';
process.env.RETRY_BACKOFF = '500ms';

const config = await resolveAsync([processEnv(), {
  TIMEOUT: 'duration',          // 30000 ms
  CACHE_TTL: 'duration',        // 300000 ms
  SESSION_DURATION: 'duration', // 9000000 ms
  RETRY_BACKOFF: 'duration'     // 500 ms
}]);

// Supported formats: 5s, 2m, 1h, 7d, 500ms, 2h30m, 1h30m15s
```

### 13) Docker/Kubernetes secrets from files

```ts
import { resolve, processEnv } from 'node-env-resolver';

// K8s mounts secrets to /run/secrets/db-password, /run/secrets/api-key

// Method 1: Using secretsDir (recommended, zero config)
const config = await resolveAsync([
  processEnv(),
  {
    DB_PASSWORD: 'file',  // Reads /run/secrets/db-password (auto kebab-case)
    API_KEY: 'file'       // Reads /run/secrets/api-key
  }
], { secretsDir: '/run/secrets' });

// Method 2: Explicit file path in env var (Go ecosystem pattern)
process.env.DB_PASSWORD_FILE = '/run/secrets/db_password';
const config = await resolveAsync([processEnv(), {
  DB_PASSWORD_FILE: 'file'  // Reads file at that path
}]);

// Method 3: Per-field secretsDir override
const config = await resolveAsync([processEnv(), {
  DB_PASSWORD: { type: 'file', secretsDir: '/custom/secrets' },
  API_KEY: 'file'  // Uses global secretsDir
}], { secretsDir: '/run/secrets' });
```

**Auto kebab-case conversion:**
- `DB_PASSWORD` → reads `db-password` file
- `API_KEY` → reads `api-key` file
- `MY_SECRET_KEY` → reads `my-secret-key` file

### 14) Computed/derived fields

```ts
import { resolve } from 'node-env-resolver';
import { withComputed } from 'node-env-resolver/utils';

const config = resolve({
  HOST: 'localhost',
  PORT: 3000,
  SSL_ENABLED: false,
  NODE_ENV: ['development', 'production'] as const,
  DB_HOST: 'localhost',
  DB_PORT: 5432,
  DB_USER: 'admin',
  DB_PASSWORD: 'secret',
  DB_NAME: 'myapp'
});

// Add computed properties (lazy getters)
const appConfig = withComputed(config, {
  // Build server URL
  url: (c) => `${c.SSL_ENABLED ? 'https' : http()}://${c.HOST}:${c.PORT}`,
  
  // Environment checks
  isProd: (c) => c.NODE_ENV === 'production',
  isDev: (c) => c.NODE_ENV === 'development',
  
  // Build database connection URL
  databaseUrl: (c) => 
    `postgres://${c.DB_USER}:${c.DB_PASSWORD}@${c.DB_HOST}:${c.DB_PORT}/${c.DB_NAME}`,
  
  // Compute server options
  serverOptions: (c) => ({
    host: c.HOST,
    port: c.PORT,
    cors: c.NODE_ENV !== 'production',
    compression: c.NODE_ENV === 'production'
  })
});

// Use computed properties
console.log(appConfig.url);         // 'http://localhost:3000'
console.log(appConfig.databaseUrl); // 'postgres://admin:secret@localhost:5432/myapp'
console.log(appConfig.isProd);      // false
```

### 15) Custom separators and validation

```ts
// Semicolon separator
process.env.ITEMS = 'item1;item2;item3';

const config = resolve({
  ITEMS: { type: 'string[]', separator: ';' }
});

// Empty string handling (secure by default)
process.env.API_KEY = '';  // Empty!

// ❌ This throws: "API_KEY cannot be empty"
const config = resolve({
  API_KEY: string()  // Required, empty rejected
});

// ✅ Use optional to allow empty → undefined
const config = resolve({
  API_KEY: string({optional:true})  // Empty becomes undefined
});

// ✅ Or explicitly allow empty strings (rare)
const config = resolve({
  ALLOW_EMPTY: { type: string(), allowEmpty: true }  // '' is valid
});
```

### 16) Per-Config Audit Tracking

When you have multiple `resolve()` calls, get audit logs specific to each config:

```ts
import { resolve, getAuditLog } from 'node-env-resolver';

const appConfig = resolve({
  PORT: 3000,
  API_KEY: string()
}, { enableAudit: true });

const dbConfig = resolve({
  DATABASE_URL: postgres(),
  DB_POOL_SIZE: 10
}, { enableAudit: true });

// Get audit logs for specific config (NEW!)
const appAudit = getAuditLog(appConfig);   // Only appConfig events
const dbAudit = getAuditLog(dbConfig);     // Only dbConfig events

// Still works: get ALL audit events (backward compatible)
const allAudit = getAuditLog();            // All events

console.log('App audit:', appAudit);
// [
//   { type: 'env_loaded', key: 'PORT', source: 'process.env', ... },
//   { type: 'env_loaded', key: 'API_KEY', source: 'process.env', ... },
//   { type: 'validation_success', ... }
// ]

console.log('DB audit:', dbAudit);
// [
//   { type: 'env_loaded', key: 'DATABASE_URL', source: 'process.env', ... },
//   { type: 'env_loaded', key: 'DB_POOL_SIZE', source: 'process.env', ... },
//   { type: 'validation_success', ... }
// ]
```
---

## Minimal Signature Cheatsheet

```ts
// Primary - throws on error (single source: process.env)
resolve(schema: Schema, options?: ResolveOptions): TypedConfig

// Primary - throws on error (multiple SYNC sources) - NEW!
resolve(...tuples: [SyncResolver, Schema][], options?: ResolveOptions): TypedConfig

// Primary - throws on error (multiple sources, async - supports both sync and async resolvers)
resolveAsync(...tuples: [Resolver, Schema][], options?: ResolveOptions): Promise<MergedConfig>

// Safe - returns result object (single source: process.env)
safeResolve(schema: Schema, options?: ResolveOptions): { success: true, data: TypedConfig } | { success: false, error: string }

// Safe - returns result object (multiple SYNC sources) - NEW!
safeResolve(...tuples: [SyncResolver, Schema][], options?: ResolveOptions): { success: true, data: TypedConfig } | { success: false, error: string }

// Safe - returns result object (multiple sources, async)
saferesolveAsync(...tuples: [Resolver, Schema][], options?: ResolveOptions): Promise<{ success: true, data: MergedConfig } | { success: false, error: string }>

// AWS convenience functions (node-env-resolver-aws)
resolveSsm(ssmOptions, schema, resolveOptions?): Promise<TypedConfig>
safeResolveSsm(ssmOptions, schema, resolveOptions?): Promise<{ success, data?, error? }>
resolveSecrets(secretsOptions, schema, resolveOptions?): Promise<TypedConfig>
safeResolveSecrets(secretsOptions, schema, resolveOptions?): Promise<{ success, data?, error? }>

// Resolvers
interface Resolver {
  name: string;
  load(): Promise<Record<string,string>>;
  loadSync?(): Record<string,string>;
  metadata?: Record<string, unknown>;
}

// Built-in resolvers
processEnv(): Resolver
dotenv(path?: string | { path?: string, expand?: boolean }): Resolver

// AWS resolvers (node-env-resolver-aws)
awsSecrets(options: { secretId: string, region?: string, parseJson?: boolean }): Resolver
awsSsm(options: { path: string, region?: string, recursive?: boolean }): Resolver

// Utilities (node-env-resolver/utils)
cached(resolver: Resolver, opts?: CacheOptions): Resolver
awsCache(opts?: { ttl?, maxAge?, staleWhileRevalidate? }): CacheOptions  // AWS-optimized defaults
retry(resolver: Resolver, maxRetries?: number, delayMs?: number): Resolver
withPrefix(resolver: Resolver, prefix: string): Resolver  // Strip prefix from keys
withNamespace(resolver: Resolver, namespace: string): Resolver  // Filter by namespace
withAliases(resolver: Resolver, aliases: Record<string, string[]>): Resolver  // Support multiple names
withTransform(resolver: Resolver, transforms: Record<string, (val: string) => string>): Resolver
withComputed<T>(config: T, computed: Record<string, (c: T) => any>): T & ComputedFields  // Add derived properties
TTL.short, TTL.minute, TTL.minutes5, TTL.minutes15, TTL.hour, TTL.hours6, TTL.day  // Constants

// Audit logging (node-env-resolver)
getAuditLog(config?: object): readonly AuditEvent[]  // NEW: Pass config for per-config audit
clearAuditLog(): void

// Options (single source - process.env only)
interface ResolveOptions {
  interpolate?: boolean;        // ${VAR} expansion (default: true)
  strict?: boolean;             // Fail on validation errors (default: true)
  enableAudit?: boolean;        // Enable audit logging (default: auto in production)
  secretsDir?: string;          // Base dir for 'file' type (Docker/K8s secrets)
}

// Options (multiple sources - both sync and async)
interface ResolveOptions {
  priority?: 'first' | 'last';  // Merge strategy (default: 'last') - NEW: works in sync too!
  interpolate?: boolean;        // ${VAR} expansion (default: true)
  strict?: boolean;             // Fail on resolver errors (default: true)
  enableAudit?: boolean;        // Enable audit logging (default: auto in production) - NEW: works in sync!
  secretsDir?: string;          // Base dir for 'file' type (Docker/K8s secrets)
  policies?: {
    allowDotenvInProduction?: boolean | string[];        // .env in production control
    enforceAllowedSources?: Record<string, string[]>;    // key → allowed provider names
  };
}
```

---

## Zod Integration

Use Zod schemas directly for validation:

```ts
import { resolveZod, safeResolveZod } from 'node-env-resolver/zod';
import { z } from 'zod';

const schema = z.object({
  PORT: z.coerce.number().default(3000),
  DATABASE_URL: z.string().url(),
  NODE_ENV: z.enum(['development', 'production', 'test']),
  DEBUG: z.coerce.boolean().optional(),
});

// Single source (process.env) - Throws on validation error
const env = await resolveZod(schema);

// Safe version - Returns result object
const result = await safeResolveZod(schema);
if (result.success) {
  console.log(result.data.PORT);
} else {
  console.error(result.error);
}
```

**With multiple resolvers:**
```ts
import { resolveZod } from 'node-env-resolver/zod';
import { processEnv, dotenv } from 'node-env-resolver';
import { awsSecrets } from 'node-env-resolver-aws';

const env = await resolveZod.async(
  [dotenv(), schema],
  [processEnv(), schema],
  [awsSecrets({ secretId: 'prod/secrets' }), schema],
  { priority: 'last' }  // AWS secrets win
);
```

**API:**
- `resolveZod(schema, options?)` - Single source, async, throws on error
- `resolveZod.async([resolver, schema], ..., options?)` - Multiple sources, async, throws on error
- `safeResolveZod(schema, options?)` - Single source, async, returns `{ success, data?, error? }`
- `safeResolveZod.async([resolver, schema], ..., options?)` - Multiple sources, async, returns result object

---

## Framework Integrations

### Next.js Integration

Zero-config Next.js integration with automatic client/server split:

```ts
// env.ts
import { resolve } from 'node-env-resolver-nextjs';

export const env = resolve({
  server: {
    DATABASE_URL: postgres(),
    API_SECRET: string(),
    PORT: 'port:3000',
  },
  client: {
    NEXT_PUBLIC_APP_URL: url(),
    NEXT_PUBLIC_GA_ID: string({optional:true}),
  }
});

// Server component or API route
import { env } from '../env';
console.log(env.server.DATABASE_URL);  // ✅ Works
console.log(env.client.NEXT_PUBLIC_APP_URL);  // ✅ Works

// Client component
'use client';
import { env } from '../env';
console.log(env.server.DATABASE_URL);  // ❌ Throws error
console.log(env.client.NEXT_PUBLIC_APP_URL);  // ✅ Works
```

**Features:**
- Automatic client/server split with `NEXT_PUBLIC_` prefix validation
- Runtime protection prevents server vars from leaking to client
- Full TypeScript support
- Works with Next.js 13+ App Router
- Safe resolve: `safeResolve()` for error handling

### Vite Integration

Zero-config Vite integration with automatic client/server split:

```ts
// env.ts
import { resolve } from 'node-env-resolver-vite';

export const env = resolve({
  server: {
    DATABASE_URL: postgres(),
    API_SECRET: string(),
    PORT: 'port:5173',
  },
  client: {
    VITE_API_URL: url(),
    VITE_ENABLE_ANALYTICS: false,
    VITE_GA_ID: string({optional:true}),
  }
});

// Server code (vite.config.ts, SSR, Node.js)
import { env } from './env';
console.log(env.server.DATABASE_URL);  // ✅ Works
console.log(env.client.VITE_API_URL);  // ✅ Works

// Browser code
import { env } from './env';
console.log(env.server.DATABASE_URL);  // ❌ Throws error
console.log(env.client.VITE_API_URL);  // ✅ Works
```

**Features:**
- Automatic client/server split with `VITE_` prefix validation
- Runtime protection prevents server vars from leaking to client
- Full TypeScript support with IntelliSense for `import.meta.env`
- **Auto-generate TypeScript definitions** for `import.meta.env`
- Works with Vite 4.x, 5.x, 6.x, and 7.x
- Framework agnostic (Vue, React, Svelte, Solid, Astro)
- Safe resolve: `safeResolve()` for error handling
- Optional Vite plugin for config-time validation and type generation

**Vite Plugin (optional):**
```ts
// vite.config.ts
import { defineConfig } from 'vite';
import { nodeEnvResolverPlugin } from 'node-env-resolver-vite/plugin';

export default defineConfig({
  plugins: [
    nodeEnvResolverPlugin({
      server: {
        DATABASE_URL: postgres(),
        API_SECRET: string(),
      },
      client: {
        VITE_API_URL: url(),
        VITE_ENABLE_ANALYTICS: false,
      },
      // Auto-generate TypeScript definitions
      generateTypes: 'src/vite-env.d.ts'
    })
  ]
});
```

**TypeScript IntelliSense:**
```ts
// vite-env.d.ts
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL: string
  readonly VITE_ENABLE_ANALYTICS: boolean
  readonly VITE_GA_ID?: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
```

---

## Test Hints (for Agents)

* Unit tests: verify types with `// @ts-expect-error` for invalid shapes.
* Integration: simulate provider order & conflicts; assert **last-wins** or **first-wins** based on priority.
* Priority tests: verify `priority: 'first'` only overwrites `undefined` values (works in both sync and async).
* **NEW:** Multiple sync resolvers: test `resolve([resolver1, schema1], [resolver2, schema2], { priority: 'first' })`.
* Security: ensure `.env` is ignored unless `dotenv()` present; assert source enforcement errors.
* Empty strings: verify empty strings are rejected by default for required fields.
* Arrays: test comma-separated parsing, custom separators, invalid items.
* Duration: test various formats (`5s`, `2m`, `1h`, `2h30m`), ensure milliseconds returned.
* File reading: test with secretsDir (auto kebab-case), explicit paths, and missing files.
* CLI args: test `--key value`, `--key=value`, `--flag`, and kebab→SNAKE conversion.
* Computed fields: test lazy evaluation, type inference, and complex derivations.
* JSON schema: ensure `'json'` parses and is typed `unknown`.
* Caching: verify cache hits/misses in metadata; test TTL expiry, `staleWhileRevalidate` behavior.
* **NEW:** Audit logging: test `getAuditLog(config)` returns only events for that config object.
* **NEW:** Audit isolation: verify multiple configs have separate audit trails.
* AWS: mock AWS SDK calls; test credential provider chain; use `awsCache()` for optimal defaults.

---

## Migration Tips (from t3-env or Zod)

* Replace `z.enum([...])` with `['a','b'] as const`.
* Replace `.default(3000)` with literal `3000`.
* Replace `runtimeEnv: process.env` with `resolve({...})` (now synchronous).
* For multi-source needs, move to `resolveAsync([provider, schema], …)` (async).
* If you prefer Zod schemas, use `resolveZod()` from `node-env-resolver/zod` (async).
* Replace custom merge logic with `priority: 'first' | 'last'` option.

---

## Performance Best Practices

1. **Cache expensive resolvers:**
   ```ts
   cached(awsSecrets({...}), { ttl: TTL.minutes5, staleWhileRevalidate: true })
   ```

2. **Call resolve() every time:**
   ```ts
   // ✅ CORRECT
   const getConfig = async () => resolveAsync([cached(...), schema]);
   app.get('/', async () => { const config = await getConfig(); });

   // ❌ WRONG
   const config = resolve({...}); // Called once
   app.get('/', () => { /* uses stale config */ });
   ```

3. **Use staleWhileRevalidate for zero-latency updates:**
   ```ts
   cached(resolver, { ttl: 300, staleWhileRevalidate: true })
   // Serves stale config while refreshing in background
   ```

4. **Choose appropriate TTL:**
   - Frequently rotating secrets: `TTL.minutes5`
   - Rarely changing config: `TTL.hour` or `TTL.hours6`

5. **Combine retry with cache:**
   ```ts
   cached(retry(awsSecrets({...}), { attempts: 3 }), { ttl: TTL.minutes5 })
   ```

---

## AWS Integration Details

### Credential Provider Chain

Credentials are automatically detected from:
1. Environment variables: `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_REGION`
2. IAM roles (EC2, Lambda, ECS)
3. AWS credentials file (`~/.aws/credentials`)
4. Explicit options (not recommended)

No explicit configuration needed in most cases.

### SSM Parameter Store

```ts
import { awsSsm, resolveSsm } from 'node-env-resolver-aws';

// Single parameter
awsSsm({ path: '/myapp/DATABASE_URL' })

// All parameters under path (recursive)
awsSsm({ path: '/myapp/production', recursive: true })

// With region
awsSsm({ path: '/myapp/config', region: 'us-west-2' })

// One-line convenience
const config = await resolveSsm({
  path: '/myapp/config',
  recursive: true
}, {
  API_ENDPOINT: url(),
  TIMEOUT: 30
});
```

### Secrets Manager

```ts
import { awsSecrets, resolveSecrets } from 'node-env-resolver-aws';

// Load JSON secret
awsSecrets({ secretId: 'myapp/production/secrets' })

// Load secret by ARN
awsSecrets({ secretId: 'arn:aws:secretsmanager:...' })

// With region
awsSecrets({ secretId: 'myapp/secrets', region: 'us-east-1' })

// One-line convenience
const secrets = await resolveSecrets({
  secretId: 'myapp/production/secrets'
}, {
  DATABASE_URL: url(),
  JWT_SECRET: string()
});
```

### IAM Permissions

**Secrets Manager:**
```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": ["secretsmanager:GetSecretValue"],
    "Resource": ["arn:aws:secretsmanager:region:account:secret:myapp/secrets-*"]
  }]
}
```

**SSM Parameter Store:**
```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": ["ssm:GetParameter", "ssm:GetParameters", "ssm:GetParametersByPath"],
    "Resource": ["arn:aws:ssm:region:account:parameter/myapp/*"]
  }]
}
```

---

**Contact:** If you're an agent proposing changes, prefer PRs that:

* Keep one source per key where possible.
* Include error messages that mention **which provider** a value came from.
* Preserve tuple order and `as const` annotations.
* Use `priority: 'first'` for development workflows, `priority: 'last'` for production.
* Document caching strategy for expensive resolvers.
* Follow the pattern: call `resolve()` every time, cache the resolver not the result.
