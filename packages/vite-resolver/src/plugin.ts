/**
 * Vite plugin for node-env-resolver
 * 
 * Validates environment variables at config resolution time and
 * optionally injects validated env vars into Vite's define config.
 */

import type { Plugin } from 'vite';
import { writeFileSync, existsSync, readFileSync } from 'fs';
import { dirname } from 'path';
import { mkdirSync } from 'fs';
import { resolve, type ViteEnvConfig, type ViteOptions } from './index.js';
import type { SimpleEnvSchema, EnvDefinition } from 'node-env-resolver';

export interface PluginOptions<TServer extends SimpleEnvSchema, TClient extends SimpleEnvSchema> extends ViteOptions {
  /**
   * Whether to inject client env vars into Vite's define config
   * This makes them available as import.meta.env.VITE_* in the browser
   * @default true
   */
  injectClientEnv?: boolean;

  /**
   * Auto-generate TypeScript definitions for import.meta.env
   * Provide a file path (e.g., 'src/vite-env.d.ts') to enable
   * @default undefined (disabled)
   */
  generateTypes?: string;
}

/**
 * Infer TypeScript type from schema definition
 */
function inferType(definition: unknown): string {
  // Handle literal values (defaults)
  if (typeof definition === 'number') return 'number';
  if (typeof definition === 'boolean') return 'boolean';
  
  // Handle array enums
  if (Array.isArray(definition)) {
    const values = definition.map(v => `'${v}'`).join(' | ');
    return values;
  }

  // Handle string type definitions
  if (typeof definition === 'string') {
    // Check if it's a literal default value
    if (!definition.includes(':') && !definition.endsWith('?') && 
        !['string', 'number', 'boolean', 'url', 'email', 'postgres', 'mysql', 
          'mongodb', 'redis', 'http', 'https', 'port', 'json', 'date', 'timestamp',
          'duration', 'file', 'string[]', 'number[]', 'url[]'].includes(definition)) {
      return 'string';
    }
    
    const isOptional = definition.endsWith('?');
    const baseType = definition.replace('?', '').split(':')[0];
    
    let tsType: string;
    if (baseType === 'string' || baseType === 'url' || baseType === 'email' || 
        baseType === 'postgres' || baseType === 'mysql' || baseType === 'mongodb' || 
        baseType === 'redis' || baseType === 'http' || baseType === 'https' ||
        baseType === 'date' || baseType === 'file') {
      tsType = 'string';
    } else if (baseType === 'number' || baseType === 'port' || baseType === 'timestamp' || baseType === 'duration') {
      tsType = 'number';
    } else if (baseType === 'boolean') {
      tsType = 'boolean';
    } else if (baseType === 'json') {
      tsType = 'unknown';
    } else if (baseType === 'string[]') {
      tsType = 'string[]';
    } else if (baseType === 'number[]') {
      tsType = 'number[]';
    } else if (baseType === 'url[]') {
      tsType = 'string[]';
    } else {
      tsType = 'string';
    }
    
    return isOptional ? `${tsType} | undefined` : tsType;
  }

  // Handle object form
  if (typeof definition === 'object' && definition !== null && 'type' in definition) {
    const def = definition as { type: string; optional?: boolean };
    const baseType = def.type.replace('?', '');
    let tsType: string;
    
    if (['string', 'url', 'email', 'postgres', 'mysql', 'mongodb', 'redis', 'http', 'https', 'date', 'file'].includes(baseType)) {
      tsType = 'string';
    } else if (['number', 'port', 'timestamp', 'duration'].includes(baseType)) {
      tsType = 'number';
    } else if (baseType === 'boolean') {
      tsType = 'boolean';
    } else if (baseType === 'json') {
      tsType = 'unknown';
    } else if (baseType === 'string[]') {
      tsType = 'string[]';
    } else if (baseType === 'number[]') {
      tsType = 'number[]';
    } else {
      tsType = 'string';
    }
    
    return def.optional ? `${tsType} | undefined` : tsType;
  }

  // Handle custom validator functions
  if (typeof definition === 'function') {
    return 'string'; // Default to string for custom validators
  }

  return 'string';
}

/**
 * Generate TypeScript definition file content
 */
function generateTypeDefinitions(clientSchema: SimpleEnvSchema): string {
  const lines: string[] = [
    '/// <reference types="vite/client" />',
    '',
    '/**',
    ' * Auto-generated by node-env-resolver-vite',
    ' * DO NOT EDIT MANUALLY - Changes will be overwritten',
    ' */',
    '',
    'interface ImportMetaEnv {'
  ];

  // Generate interface properties
  for (const [key, definition] of Object.entries(clientSchema)) {
    const tsType = inferType(definition);
    const readonly = '  readonly ';
    lines.push(`${readonly}${key}: ${tsType}`);
  }

  lines.push('}');
  lines.push('');
  lines.push('interface ImportMeta {');
  lines.push('  readonly env: ImportMetaEnv');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Vite plugin for environment variable validation and injection
 * 
 * @example
 * ```typescript
 * // vite.config.ts
 * import { defineConfig } from 'vite';
 * import { nodeEnvResolverPlugin } from 'node-env-resolver-vite/plugin';
 *
 * export default defineConfig({
 *   plugins: [
 *     nodeEnvResolverPlugin({
 *       server: {
 *         DATABASE_URL: 'postgres',
 *         API_SECRET: 'string',
 *       },
 *       client: {
 *         VITE_API_URL: 'url',
 *         VITE_ENABLE_ANALYTICS: false,
 *       },
 *       generateTypes: 'src/vite-env.d.ts'  // Auto-generate types!
 *     })
 *   ]
 * });
 * ```
 */
export function nodeEnvResolverPlugin<TServer extends SimpleEnvSchema, TClient extends SimpleEnvSchema>(
  config: ViteEnvConfig<TServer, TClient>,
  options: PluginOptions<TServer, TClient> = {}
): Plugin {
  const {
    injectClientEnv = true,
    generateTypes,
    ...resolveOptions
  } = options;

  let env: ReturnType<typeof resolve<TServer, TClient>>;

  return {
    name: 'node-env-resolver-vite',
    
    // Validate environment variables early in the config resolution
    config() {
      try {
        // Resolve and validate env vars
        env = resolve(config, resolveOptions);
        
        // Log validation success
        console.log('‚úÖ Environment variables validated successfully');
      } catch (error) {
        // Throw to prevent Vite from starting with invalid config
        console.error('‚ùå Environment validation failed:');
        throw error;
      }

      // Inject client env vars into Vite's define if enabled
      if (injectClientEnv) {
        const define: Record<string, string> = {};
        
        for (const [key, value] of Object.entries(env.client)) {
          // Convert values to JSON strings for Vite's define
          const jsonValue = JSON.stringify(value);
          define[`import.meta.env.${key}`] = jsonValue;
        }

        return {
          define
        };
      }
    },

    configResolved(resolvedConfig) {
      // Log environment info in dev mode
      if (resolvedConfig.command === 'serve' && resolvedConfig.mode === 'development') {
        console.log('\nüì¶ Environment Configuration:');
        console.log(`  ‚Ä¢ Mode: ${resolvedConfig.mode}`);
        console.log(`  ‚Ä¢ Server vars: ${Object.keys(config.server).length}`);
        console.log(`  ‚Ä¢ Client vars: ${Object.keys(config.client).length}`);
        
        // Generate TypeScript definitions if requested
        if (generateTypes) {
          try {
            const typePath = generateTypes.startsWith('/') 
              ? generateTypes 
              : `${resolvedConfig.root}/${generateTypes}`;
            
            // Check if file exists and contains custom content
            let shouldGenerate = true;
            if (existsSync(typePath)) {
              const existingContent = readFileSync(typePath, 'utf-8');
              // Only regenerate if it's our auto-generated file
              if (!existingContent.includes('Auto-generated by node-env-resolver-vite')) {
                shouldGenerate = false;
                console.log(`  ‚ö†Ô∏è  Skipping type generation: ${generateTypes} contains custom content`);
              }
            }
            
            if (shouldGenerate) {
              const typeDefinitions = generateTypeDefinitions(config.client);
              
              // Ensure directory exists
              const dir = dirname(typePath);
              if (!existsSync(dir)) {
                mkdirSync(dir, { recursive: true });
              }
              
              writeFileSync(typePath, typeDefinitions, 'utf-8');
              console.log(`  ‚úÖ Generated TypeScript definitions: ${generateTypes}`);
            }
          } catch (error) {
            console.error('  ‚ö†Ô∏è  Failed to generate types:', error instanceof Error ? error.message : String(error));
          }
        }
        
        console.log('');
      }
    }
  };
}

/**
 * Type-only export for plugin configuration
 */
export type { ViteEnvConfig, ViteOptions };

